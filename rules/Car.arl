//Offer values are based on haste, current money and approximate expected waiting time if let go 
//Bidding rules:
//Every agent either passes and let everyone go, or sends it's offer
//After getting decisions from all other agents, agent processes them and decides what can he accept
//Agent may accept lower offer than his, but cannot refuse higher offer
//If agent accepts some speed, it accepts all higher speeds
//TODO If two agents accept each other, then: 1. if some let lower offer go first, then it stays 2. wins bigger difference in offers 3. wins earlier offer
//If there are two equal offers wins agent with bigger haste, if they have equal haste wins agent TODO with smaller agent_id

//TODO check 151 
ruleset Car {
	import java.lang.String;
	import java.lang.Math;
	import java.util.ArrayList;
	import java.util.Collections;
	import java.util.List;
	import logging.Logger;
	import simulation.Agent;
	import simulation.Simulation;
	import simulation.AgentState;
	import simulation.Direction;
	import simulation.CenterPlace;
	import simulation.Action;
	import simulation.Intersection;
	import messages.OfferMsg;
	import messages.AcceptMsg;
	import com.ibm.able.rules.AbleOclSequence;
	
  	variables {
  		static Logger logger;
  	
		Agent agent;
		List cur_state;
		List offers;
		List accepts;
		static AgentState my_state;
		Action res;
		Integer speed;
		Integer n_messages = 0;
		Integer i;
		Integer j;
		Integer k;
		Integer turns_to;
		Integer len;
		static Integer max_dist;
		static Integer min_dist;

		static Intersection intersection;
		AbleOclSequence pom_seq;
		AbleOclSequence colliding;
		static CenterPlace fst_center;
		static CenterPlace lst_center;
		Integer center_len;
		static List center_path;
		static List intersecting_agents = new ArrayList();
		CenterPlace temp;
		CenterPlace temp2;
		Double expected_wait_time;
		Double expected_total_time;
		
		AgentState car;
		AgentState car2;
		CenterPlace p;
		Double tmp;
		Integer accepted;
		Integer paying;
		
		Double max_spend;
		Double sum_wait;
		static Integer offer;
		
		static List accepted_offers;
		Integer delta_pts;

		//TODO for now it doesn't consider agents behind me
		Expression Collides = car.agent_id != my_state.agent_id and car.waiting_time == 0 and
			(intersection.isInFront(my_state, car) or intersection.trajectoriesIntersect(my_state, car));
		Selector collidingCars = new Selector(this.getVariable("car"), Collides, true);
	}

	inputs{agent, cur_state, offers, accepts};

	outputs{res};

	//TODO serve case when agent commits without responding to offer
	void process() using Script {
	: logger = new Logger(agent.getAgentId());
	: logger.trace("processing");
	: len = agent.getLength();
	: if(offers == null and accepts == null) {
			invokeRuleBlock("processState");
		}
	: if(offers != null) {
			invokeRuleBlock("processOffers");
		} 
	: if(accepts != null) {
			invokeRuleBlock("processAccepts");
		}		
	}
	
	void processState() using Script {
	: logger.trace("processing State");
	: my_state = cur_state.get(agent.getAgentId());	
	: intersection = new Intersection(len);
	: pom_seq = new AbleOclSequence(cur_state);
	: colliding = pom_seq.select(collidingCars);		
	: wm.assertAll(colliding.asSequence());
	: fst_center = intersection.getFirstPlace(my_state);
	: lst_center = intersection.getLastPlace(my_state);
	: center_path = intersection.getPath(fst_center, lst_center);
	: if(my_state.place == Direction.C) 
		center_path.remove(0);
	: center_len = center_path.size();
	: logger.debug("fst_center = %s, lst_center = %s, center_len = %d", String.valueOf(fst_center), String.valueOf(lst_center), center_len);
	: wm.assertAll(intersection.getPlaces());
	: max_dist = my_state.max_speed;
	: min_dist = my_state.max_speed;
	: invokeRuleBlock("computeMaxDist");
	: logger.debug("max_dist = %d", max_dist);
	: invokeRuleBlock("computeAction");
	}
	
	void computeMaxDist() using PatternMatch {
	: logger.trace("computing max dist");
	: when(AgentState car ((intersection.isInFront(my_state, car) || (car.place == Direction.C && center_path.contains(intersection.getAgentPlace(car)))) && 
							intersection.distance(my_state, car) <= max_dist)) do {
			logger.debug("car on trajectory: %d", car.agent_id);
			max_dist = intersection.distance(my_state, car) - 1;
		}
	}

	void computeAction() using Policy {
	: logger.trace("computing Action");
	[1] : preconditions (my_state.dest == my_state.place) decisions {
			//If I'm after intersection, then greedly take max possible speed
			speed = max_dist;
			res = Action.commit(speed);
			logger.trace("greedy speed: %d", speed);
		}
	[1] : preconditions (my_state.place != Direction.C and my_state.position + max_dist < len) decisions {
			//If I cannot arrive intersection, act greedly (TODO proposing car in front of me to move)
			speed = max_dist;
			res = Action.commit(speed);
			logger.trace("greedy speed: %d", speed);
		}
	[0] : preconditions (true) decisions {
			invokeRuleBlock("computeStatistics");
			min_dist = Math.min(min_dist, max_dist);
			logger.debug("min_dist = %d", min_dist);
			if(min_dist == max_dist) {
				speed = max_dist;
				res = Action.commit(speed);			
				logger.trace("greedy speed: %d", speed);
			} else {
				invokeRuleBlock("valuePlaces");
				offer = agent.computeOffer(expected_total_time); 
				res = Action.offer(offer);
			}
		}
	}
	
	void computeStatistics() using PatternMatch {
	: logger.trace("computing Statistics");
	//for every such position compute how on many agent trajectories it lies (and some addidtional statistics) 
	: when(AgentState car (car.place != car.dest) &
		CenterPlace p (intersection.onTrajectory(p, car))) do {
			logger.debug("intersection %d on path of %d, distance=%d ", p.id, car.agent_id, intersection.distance(car, p));
			turns_to = (intersection.distance(car, p) - 1) / car.max_speed;
			i = p.future_agents.get(turns_to) + 1;
			logger.debug("turns_to = %d, i = %d", turns_to, i);
			p.future_agents.set(turns_to, i);
			if(turns_to == 0) {
				p.agents.add(car.agent_id);
				intersecting_agents.add(car.agent_id);
			}
			if(turns_to == 0 and center_path.contains(p)) {
				min_dist = Math.min(min_dist + 1, intersection.distance(my_state, p)) - 1;
			}
		}
	}
		
	void valuePlaces() using Script {
	: logger.trace("computing Offer");
	: expected_total_time = 0;  	
	: for(i = center_path.size() - 1 ; i >= 0 ; i = i - 1) {
			invokeRuleBlock("expectedWaiting(Integer)", new Object[] {i}); //cannot nest loops
			//expected waiting time + time to cross intersection (if going with max_speed)
			expected_total_time = expected_total_time + expected_wait_time + ((center_len - i - 1) / agent.getMaxSpeed() + 1);			
			logger.debug("expected_total_time = %f, expected_wait_time = %f", expected_total_time, expected_wait_time);
		}
	}
	
	//TODO think about it
	void expectedWaiting(Integer place_idx) using Script {
	: j = 1;
	: temp = center_path.get(place_idx);
	//TODO sth like j = List.findFirst (and rename j to sth meaningfull)	
	: while ( j < len and temp.future_agents.get(j) > 0 ) do {
			j = j+1;
		}
	: j = j - 1;
	: expected_wait_time = 0;
	: for( ; j > 0; j = j - 1) {
			//assume that every agent have the same chance to cross intersection in this place 
			//it's technically not expected value
			expected_wait_time = (1 - 1/((Double) temp.future_agents.get(j) + 1))*(expected_wait_time + 1); 
		}
	: logger.debug("expected_wait_time = %f for place %d", expected_wait_time, place_idx);
	}
		
	void processOffers() using Script {
	: logger.trace("processing Offers");
	: wm.assertAll(offers);
	: accepted_offers = new ArrayList();
	: logger.debug("my offer = %d", offer);  
	: invokeRuleBlock("getAccOffers");
	: res = Action.accept(accepted_offers); 
	}

	void getAccOffers() using PatternMatch {
	: when(OfferMsg m (intersecting_agents.contains(m.agent_id))) do {
			car = cur_state.get(m.agent_id);
			if(agent.acceptsOffer(car, m.offer, offer)) {
				logger.debug("accepted offer %d from agent %d", m.offer, m.agent_id);
				accepted_offers.add(m.agent_id);
			} 
		}	
	}
	
	void processAccepts() using Script {
	: logger.trace("processing Accepts");
	: wm.assertAll(accepts);
	: speed = -1;
	: delta_pts = 0;
	: paying = 0;	
	: for(i = 0 ; i < center_path.size(); i = i + 1) {
			temp = center_path.get(i);	
			if(intersection.distance(my_state, temp) > min_dist) { //TODO sth prettier
				if(!temp.agents.isEmpty()) {
					invokeRuleBlock("checkAgents(CenterPlace)", new Object[] {temp}); //cannot nest loops
					if(accepted == 1) {
						if(speed == -1) speed = intersection.distance(my_state, temp) - 1; //TODO refactor 
					} else {
						paying = 1;
					}
				}
			}
		}
	: if(speed == -1) speed = max_dist;
	: if(paying == 1) delta_pts = delta_pts - offer;
	: logger.trace("speed = %d, delta_pts = %d", speed, delta_pts);	
	: k = agent.getPoints() + delta_pts;
	: agent.setPoints(k);
	: res = Action.commit(speed);
	}
	
	void checkAgents(CenterPlace p) using Script {
	: logger.trace("checking agents for place %d", p.getId());
	: for(j = 0; j < p.getAgents().size(); j = j + 1) {
			k = p.getAgents().get(j);
			car = cur_state.get(k);
			if(accepted_offers.contains(car.agent_id)) {
				accepted = 1;
				invokeRuleBlock("checkIfAccepted(CenterPlace,AgentState)", new Object[] {p, car});
				if(accepted == 1) {
					logger.trace("agent %d blocks my path on position %d", car.agent_id, p.getId());
					invokeRuleBlock("getPayment(AgentState)", new Object[] {car});
					break;
				}
			}
		}
	}
	
	void checkIfAccepted(CenterPlace dest, AgentState car) using PatternMatch {
	: logger.debug("checking if %s is accepted for %s", dest.toString(), car.toString());
	//Find place on which car is forbidden to enter
	: when(CenterPlace p (true) &
		AcceptMsg msg (msg.agent_id != car.agent_id and p.onPathOf(msg.agent_id) and !msg.offers.contains(car.agent_id)) &
		OfferMsg offer (offer.agent_id == car.agent_id)) do {
			if(intersection.distance(car, p) <= intersection.distance(car, dest)) {
				accepted = 0;
			}
		}
	}
	
	void getPayment(AgentState car) using PatternMatch {
	: when(OfferMsg offer (offer.agent_id == car.agent_id)) do {
			delta_pts = delta_pts + offer.offer; 
		}
	}	
}