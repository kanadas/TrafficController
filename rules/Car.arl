//Offer values are based on haste, current money and approximate expected waiting time if let go 
//Bidding rules:
//Every agent either passes and let everyone go, or sends it's offer
//After getting decisions from all other agents, agent processes them and decides what can he accept
//Agent may accept lower offer than his, but cannot refuse higher offer
//If agent accepts some speed, it accepts all higher speeds
//TODO If two agents accept each other, then: 1. if some let lower offer go first, then it stays 2. wins bigger difference in offers 3. wins earlier offer
//If there are two equal offers wins agent with bigger haste, if they have equal haste wins agent TODO with smaller agent_id

//TODO: wtf with offers per speed??? now proposing only 4 speed 1 should also for 2 (but its useless)
 
ruleset Car {
	import java.lang.String;
	import java.lang.Math;
	import java.util.ArrayList;
	import java.util.Collections;
	import java.util.List;
	import simulation.Agent;
	import simulation.Simulation;
	import simulation.AgentState;
	import simulation.Position;
	import simulation.IntersectionPlace;
	import simulation.Action;
	import messages.OfferMsg;
	import messages.AcceptMsg;
	import com.ibm.able.rules.AbleOclSequence;
	
  	variables {
		Agent agent;
		List cur_state;
		List offers;
		List accepts;
		static AgentState my_state;
		Action res;
		Integer speed;
		Integer n_messages = 0;
		Integer turn;
		Integer i;
		Integer j;
		Integer k;
		Integer len;
		static Integer max_dist;
		static Integer min_dist;

		AbleOclSequence pom_seq;
		AbleOclSequence colliding;
		List intersection = new ArrayList();
		AbleOclSequence my_intersection;
		Integer fst_inters;
		Integer lst_inters;
		Integer inters_len;
		static List inters_path;
		IntersectionPlace temp;
		IntersectionPlace temp2;
		Float multiplier;
		
		AgentState car;
		AgentState car2;
		IntersectionPlace p;
		Expression Collides = car.agent_id != my_state.agent_id and car.waiting_time == 0 and (
			(car.place != Position.C and car.place == my_state.place and car.position > my_state.position) or 
			(car.place != my_state.place and car.dest == my_state.dest) or 
			(turn == 2 and (car.place == (my_state.place.num + 3) % 4 or car.dest == (my_state.place.num + 3) % 4)) or
			(turn == 1 and !(car.place == (my_state.place.num + 1) % 4 and car.dest == my_state.place)));
		Selector colliding_cars = new Selector(this.getVariable("car"), Collides, true);
		Expression myIntersection = (p.id != my_state.position or my_state.place != Position.C) and (fst_inters - p.id + 4) % 4 < inters_len;
		Selector get_my_intersection = new Selector(this.getVariable("p"), myIntersection, true);
		Float tmp;
		
		Float max_spend;
		Float sum_wait;
		List offer;
		
		static List acc_offers;
		static List speeds;
		Integer to_pay;

		Boolean dbg_bool;
		List dbg_list;
	}

	inputs{agent, cur_state, offers, accepts};

	outputs{res};

	void process() using Script {
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] processing");
	: len = agent.getLength();
	
	: if(offers == null and accepts == null) {
			invokeRuleBlock("processState");
		}
	: if(offers != null) {
			invokeRuleBlock("processOffers");
		} 
	: if(accepts != null) {
			invokeRuleBlock("processAccepts");
		}		
	}
	
	//TODO in round 84 results in speed 1 instead of 2
	void processAccepts() using Script {
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] processing Accepts");
	
	: wm.assertAll(accepts);
	: invokeRuleBlock("removeNotAccepted");
	
//	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] removed not accepted");
	
	: invokeRuleBlock("computeBestOffer");
	
//	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] computed best offers");
	
	: speed = min_dist - 1;
	: to_pay = 0;
	: for(j = 0 ; j < inters_path.size(); j = j + 1) {
			temp = inters_path.get(j);			
			if(temp.distance >= min_dist) {
				//TODO it doesnt work (i may not win because lost before)
				if(temp.best_offer_id == my_state.agent_id) {
					speed = speed + 1;
					to_pay = temp.best_offer;							
				} else {
					k = agent.getPoints() + temp.best_offer / 2;
					agent.setPoints(k);
					//TODO it don't work correctly
					break;
				}
			}
		}
	
//	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] speed = " + String.valueOf(speed) + " to_pay = " + String.valueOf(to_pay));	
	
	: k = agent.getPoints() - to_pay;
	: agent.setPoints(k);
	: res = new Action(speed);
	}
	
	void computeBestOffer() using PatternMatch {
	//We can assume that all agreed on every offer fulfilling this conditions
	: when(IntersectionPlace p (p.distance >= min_dist and p.distance < max_dist) &
		OfferMsg m (p.onPathOf(m.agent_id)) ) do {
			//println("[Agent " + String.valueOf(agent.getAgentId()) + "] computing " + String.valueOf(p) + " " + String.valueOf(m));			
			car = cur_state.get(m.agent_id);
			i = p.distanceFrom(car, len);			
			//Agents can let someone go even if he had lower offer
			//Only offers allowed by everyone are: highest offer and "let go" offers
			//Lowest offer is offer that everyone else "let go" so it wins
			//-1 means no offer
			if(p.best_offer < 0 or p.best_offer > m.offers.get(i) ) {
				p.best_offer = m.offers.get(i);
				p.best_offer_id = m.agent_id;
				p.best_offer_speed = i;
			} else if(p.best_offer == m.offers.get(i)) {
				car2 = cur_state.get(p.best_offer_id);
				if(car.haste > car2.haste or (car.haste == car2.haste and m.agent_id < p.best_offer_id)) {
					p.best_offer = m.offers.get(i);
					p.best_offer_id = m.agent_id;
					p.best_offer_speed = i;
				}
			}
			
			println("[Agent " + String.valueOf(agent.getAgentId()) + "] best_offer = " + String.valueOf(p.best_offer));
		}
	}

	void removeNotAccepted() using PatternMatch {
	//Check my offers
	: when(IntersectionPlace p (p.distance >= min_dist and p.distance < max_dist) &
		AcceptMsg am (p.onPathOf(am.agent_id))) do {
			//println("[Agent " + String.valueOf(agent.getAgentId()) + "] my " + String.valueOf(p) + " " + String.valueOf(am));
			j = am.offers.indexOf(agent.getAgentId());			
			if(j < 0 or am.speeds.get(j) > p.distance) {
				//my offer was not accepted
				
				//println("[Agent " + String.valueOf(agent.getAgentId()) + "] p " + String.valueOf(p.best_offer) + String.valueOf(p.best_offer_id) + String.valueOf(p.best_offer_speed));
				//TODO fix this
				p.best_offer = -1;
				p.best_offer_id = -1;
				p.best_offer_speed = -1;
			}
			
			//println("[Agent " + String.valueOf(agent.getAgentId()) + "] kupa");
		}
	//Check if I accepted
	:  when(IntersectionPlace p (p.distance >= min_dist and p.distance < max_dist) &
		OfferMsg om (p.onPathOf(om.agent_id))) do {
			//println("[Agent " + String.valueOf(agent.getAgentId()) + "] I " + String.valueOf(p) + " " + String.valueOf(om));			
			car = cur_state.get(om.agent_id);
			i = p.distanceFrom(car, len);
			j = acc_offers.indexOf(om.agent_id);
			if(j < 0 or speeds.get(j) > i) {
				//he is not allowed to go there, so remove him from possible collision list
				p.agents.remove(new Integer(om.agent_id));
			}			
		}
	//Check other's offers
	: when(IntersectionPlace p (p.distance >= min_dist and p.distance < max_dist) &
		OfferMsg om (p.onPathOf(om.agent_id)) &
		AcceptMsg am (am.agent_id != om.agent_id and p.onPathOf(am.agent_id))) do {
		
			println("[Agent " + String.valueOf(agent.getAgentId()) + "] other " + String.valueOf(p) + " " + String.valueOf(am) + " " + String.valueOf(om));
			
			car = cur_state.get(om.agent_id);
			i = p.distanceFrom(car, len);
			j = am.offers.indexOf(om.agent_id);
			if(j < 0 or am.speeds.get(j) > i) {
				//he is not allowed to go there, so remove him from possible collision list 
				p.agents.remove(om.agent_id);
			}
		}
	}

	void processOffers() using Script {
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] processing Offers");
	
	: wm.assertAll(offers);
	: acc_offers = new ArrayList();
	: speeds = new ArrayList();
	: invokeRuleBlock("getAccOffers");
	: res = new Action(acc_offers, speeds); 
	}
	
	void getAccOffers() using PatternMatch {
	: when(IntersectionPlace p (p.distance >= min_dist and p.distance < max_dist) &
		OfferMsg m (p.onPathOf(m.agent_id)) ) do {
			//println("[Agent " + String.valueOf(agent.getAgentId()) + "] geting place: " + p.toString() + " offer: " + m.toString());		
			car = cur_state.get(m.agent_id);
			i = p.distanceFrom(car, len);
			if(p.best_offer < m.offers.get(i) or (p.best_offer == m.offers.get(i) and 
												 (car.haste > agent.getHaste() or (car.haste == agent.getHaste() and m.agent_id < p.best_offer_id)))) {
				j = acc_offers.indexOf(m.agent_id);				
				if(j >= 0) {
					speeds.set(j, Math.min(speeds.get(j), i));
				} else {
					acc_offers.add(m.agent_id);
					speeds.add(i);
				}
			}
		}
	}

	void processState() using Script {
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] processing State");
	
	: my_state = cur_state.get(agent.getAgentId());
	: pom_seq = new AbleOclSequence(cur_state);
	: colliding = pom_seq.select(colliding_cars);		
	: wm.assertAll(colliding.asSequence());
	: max_dist = my_state.max_speed + 1;
	: min_dist = my_state.max_speed + 1;
	: if(agent.getDest() == my_state.dest) then {
			turn = (agent.getDest().num - agent.getFrom().num + 4) % 4;
		} else {
			turn = (agent.getFrom().num - agent.getDest().num + 4) % 4;
		}
	//First and last positions on intersection center
	: if(my_state.place != Position.C) then {
			fst_inters = my_state.place.num;
		} else { 
			fst_inters = (my_state.position + 3) % 4;
		}
	: lst_inters = (my_state.dest.num + 1) % 4;
	: if(my_state.place == Position.C and lst_inters == my_state.position) fst_inters = lst_inters;
	//length of my path on the center of intersection (car moves in opposite direction than numbers grow)
	: inters_len = (fst_inters - lst_inters + 4) % 4 + 1;
	: if(my_state.place == my_state.dest) inters_len = 0;
	: for(i = 0; i < 4; ++i) {
			intersection.add(new IntersectionPlace(i, len));
		}
	//find center positions on agent's path
	: pom_seq = new AbleOclSequence(intersection);
	: my_intersection = pom_seq.select(get_my_intersection);
	: for(i = 0; i < my_intersection.size(); i = i + 1) {
			p = my_intersection.get(i);
			p.distance = p.distanceFrom(my_state, len);
			
			println("[Agent " + String.valueOf(agent.getAgentId()) + "] intersection on trajectory: " + String.valueOf(p.id));
		}
	
	: if(my_intersection.size() != inters_len) 
		println("BUG [Agent " + String.valueOf(agent.getAgentId()) + "] my_intersection.size() = " + String.valueOf(my_intersection.size()) + " inters_len = " + String.valueOf(inters_len));
	
	: wm.assertAll(my_intersection);
	: invokeRuleBlock("computeStatistics");
	
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] min_dist = " + String.valueOf(min_dist) + " max_dist = " + String.valueOf(max_dist));
	
	: invokeRuleBlock("computeAction");
	}

	void computeAction() using Policy {
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] computing Action");
	
	[1] : preconditions (my_state.dest == my_state.place) decisions {
			//If I'm after intersection, then greedly take max possible speed
			speed = max_dist - 1;
			res = new Action(speed);
			
			println("[Agent " + String.valueOf(agent.getAgentId()) + "] greedy speed: " + String.valueOf(speed));
		}
	[1] : preconditions (my_state.place != Position.C and my_state.position + max_dist < len) decisions {
			//If I cannot arrive intersection, act greedly (TODO proposing car in front of me to move)
			speed = max_dist - 1;
			res = new Action(speed);
			
			println("[Agent " + String.valueOf(agent.getAgentId()) + "] greedy speed: " + String.valueOf(speed));
		}
	[1] : preconditions (min_dist == max_dist) decisions {
			//Have only one option
			speed = max_dist - 1;
			res = new Action(speed);
			
			println("[Agent " + String.valueOf(agent.getAgentId()) + "] greedy speed: " + String.valueOf(speed));
		}
	[0] : preconditions (min_dist < max_dist) decisions {
			invokeRuleBlock("valuePlaces");
			invokeRuleBlock("computeOffer");
			res = new Action(offer);
		}
	}
	
	
	//Only option for getting here is possibility of crossing intersection this moment
	//and having possible collision after min_dist steps
	void computeOffer() using Script {
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] computing Offer");
	
	: max_spend = ((Float) agent.getHaste()) / 5 * agent.getPoints();
	
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] max_spend = " + String.valueOf(max_spend));
	
	: if(my_state.place != Position.C) {
			i = min_dist - (len - my_state.position);
		} else { 
			i = min_dist - 1;
		}	
	: temp = inters_path.get(i);	
	: sum_wait = temp.expect_tot_time;
	: offer = new ArrayList();
	: for( j = 0; j < min_dist; j = j + 1) {
			offer.add(0);
		}
	: for(j = min_dist ; j < max_dist and i < inters_path.size(); j = j + 1, i = i + 1) {
			temp = inters_path.get(i);
			tmp = temp.expect_tot_time / sum_wait * max_spend;
			k = Math.round(tmp);			
			offer.add(k);
			temp.best_offer = k;
			temp.best_offer_id = my_state.agent_id;
			temp.best_offer_speed = j;
			if(temp.distance != j) println("BUG [Agent " + String.valueOf(agent.getAgentId()) + "] temp.distance = " + String.valueOf(temp.distance) + ", j = " + String.valueOf(j));
		}
	
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] offer: " + String.valueOf(offer));
	}

	void valuePlaces() using Script {
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] computing Offer");
	
	: inters_path = (List) my_intersection;
	: Collections.sort(inters_path); //sort ascending by distance	
	: temp = inters_path.get(0);
	: if(inters_path.size() > 0 and fst_inters != temp.id)  println("BUG [Agent " + String.valueOf(agent.getAgentId()) + "] fst_inters = " + String.valueOf(fst_inters) + " inters_path.first = " + String.valueOf(temp));	
	: for(i = inters_path.size() - 1 ; i >= 0 ; i = i - 1) {
			temp = inters_path.get(i);			
			temp.expect_wait_time = 0;
			invokeRuleBlock("expectedWaiting(Integer)", new Object[] {i}); //cannot nest loops
			//expected waiting time + time to cross intersection (if going with max_speed)
			temp.expect_tot_time = ((inters_len - i - 1) / agent.getMaxSpeed() + 1) + temp.expect_wait_time;
			
			//println("[Agent " + String.valueOf(agent.getAgentId()) + "] " + String.valueOf(i) + ": " + temp.toString() + " expected_tot_time = " + String.valueOf(temp.expect_tot_time));
		}
	}
	
	void expectedWaiting(Integer place_idx) using Script {
	: j = 1;
	: temp = inters_path.get(place_idx);
	
	//: println("[Agent " + String.valueOf(agent.getAgentId()) + "] dupa " + temp.future_agents.toString());
	
	: while ( j < len - 1 and temp.future_agents.get(j) > 0 ) do {
			j = j+1;
		}
	
	//: println("[Agent " + String.valueOf(agent.getAgentId()) + "] kupa");
	: temp.expect_wait_time = 0;
		
	: for( ; j > 0; j = j - 1) {
			//assume that every agent have the same chance to cross intersection in this place 
			//it's technically not expected value
			multiplier = 1 - 1/((Float) temp.future_agents.get(j) + 1);
			temp.expect_wait_time = multiplier*(temp.expect_wait_time + 1); 
		}
	
	//: println("[Agent " + String.valueOf(agent.getAgentId()) + "] mada " + String.valueOf(place_idx) + " " + String.valueOf(inters_len));	
	
	: if(place_idx < inters_len - 1) then {
			temp2 = inters_path.get(place_idx + 1);
			temp.expect_wait_time = temp.expect_wait_time + temp2.expect_wait_time;
		}
	}
	
	
	void computeStatistics() using PatternMatch {
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] computing Statistics");
	
//	: when(AgentState car (true)) do {
//		println("[Agent " + String.valueOf(agent.getAgentId()) + "] WAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA " + String.valueOf(car.agent_id));
//	}
	
	//When there is another car on my trajectory i cannot go further
	//This covers cases when this car is not in the center
	: when(AgentState car (car.place != Position.C and ((my_state.place == car.place and my_state.position < car.position and my_state.position + max_dist > car.position) or
														(my_state.dest == car.place and my_state.place != my_state.dest and
														((my_state.place == Position.C and max_dist - inters_len > car.position) or
														(my_state.place != Position.C and my_state.position + max_dist - len - inters_len > car.position)))))) do {
			max_dist = car.position - my_state.position;
			min_dist = Math.min(min_dist, max_dist);
			
			println("[Agent " + String.valueOf(agent.getAgentId()) + "] car on trajectory: " + String.valueOf(car.agent_id));
		}
	//for every such position compute how on many agent trajectories it lies (and some addidtional statistics) 
	: when(IntersectionPlace p (true) & 
		AgentState car ((car.place != Position.C and (car.place.num - p.id + 4) % 4 <= (car.place.num - ((car.dest.num + 1) % 4) + 4) % 4) or
						(car.place == Position.C and (car.position - p.id + 4) % 4 <= (car.place.num - ((car.dest.num + 1) % 4) + 4) % 4))) do {
						
			println("[Agent " + String.valueOf(agent.getAgentId()) + "] intersection " + String.valueOf(p.id) + " on path of " + String.valueOf(car.agent_id));
			
			i = (p.distanceFrom(car, len) - 1) / car.max_speed;
			//i = number of turns car needs to get to p assuming it will drive with max_speed
			j = p.future_agents.get(i) + 1;
			
			println("[Agent " + String.valueOf(agent.getAgentId()) + "] i = " + String.valueOf(i) + " j = " + String.valueOf(j) + " p.distance = " + String.valueOf(p.distance));
			
			p.future_agents.set(i, j);
			if(car.place == Position.C and car.position == p.id) {
				max_dist = Math.min(max_dist, p.distance);
				min_dist = Math.min(min_dist, max_dist);
			}
			if(i == 0) {
				min_dist = Math.min(min_dist, p.distance); 
				p.agents.add(car.agent_id);
			}
		}
	}
	
}