//Offer values are based on haste, current money and approximate expected waiting time if let go 
//Bidding rules:
//Every agent either passes and let everyone go, or sends it's offer
//After getting decisions from all other agents, agent processes them and decides what can he accept
//Agent may accept lower offer than his, but cannot refuse higher offer
//If agent accepts some speed, it accepts all higher speeds
//TODO If two agents accept each other, then: 1. if some let lower offer go first, then it stays 2. wins bigger difference in offers 3. wins earlier offer
//If there are two equal offers wins agent with bigger haste, if they have equal haste wins agent TODO with smaller agent_id 
ruleset Car {
	import java.lang.String;
	import java.lang.Math;
	import java.util.ArrayList;
	import java.util.Collections;
	import java.util.List;
	import simulation.Agent;
	import simulation.Simulation;
	import simulation.AgentState;
	import simulation.Position;
	import simulation.IntersectionPlace;
	import simulation.Action;
	import messages.OfferMsg;
	import messages.AcceptMsg;
	import com.ibm.able.rules.AbleOclSequence;
	
  	variables {
		Agent agent;
		List in_state;
		List cur_state;
		List offers;
		List accepts;
		AgentState my_state;
		Action res;
		Integer speed;
		Integer n_messages = 0;
		Integer turn;
		Integer i;
		Integer j;
		Integer k;
		Integer len;
		Integer max_dist;
		Integer min_dist;

		AgentState car;
		AgentState car2;
		Expression Collides = car.place != car.dest and (car.place != my_state.place or car.position > my_state.position) and 
			car.dest == agent.dest or 
			(turn == 2 and (car.place == (my_state.place.num + 3) % 4 or car.dest == (my_state.place.num + 3) % 4)) or
			(turn == 1 and !(car.place == (my_state.place.num + 1) % 4 and car.dest == my_state.place));
		Selector colliding_cars = new Selector(this.getVariable("car"), Collides, true);
		AbleOclSequence state_col;
		AbleOclSequence colliding;
		List intersection = new ArrayList();
		Integer fst_inters;
		Integer lst_inters;
		Integer inters_len;
		List inters_path = new ArrayList();
		IntersectionPlace temp;
		IntersectionPlace temp2;
		Float multiplier;
		Float tmp;
		
		Float max_spend;
		Float sum_wait;
		List offer;
		
		List acc_offers;
		List speeds;
		Integer to_pay;

		String dbg_msg;		
	}

	inputs{agent, in_state, offers, accepts};

	outputs{res};

	void process() using DecisionTree {
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] processing");
	
	: if(offers == null and accepts == null) then {
			invokeRuleBlock("processState");
		}
	: if(offers != null) then {
			invokeRuleBlock("processOffers");
		}
	: if(accepts != null) then {
			invokeRuleBlock("processAccepts");
		}		
	}
	
	void processAccepts() using Script {
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] processing Accepts");
	
	: wm.assertAll(accepts);
	: invokeRuleBlock("removeNotAccepted");
	: invokeRuleBlock("computeBestOffer");
	: speed = min_dist;
	: to_pay = 0;
	: i = 0;
	: for(j = 0 ; j < inters_path.size(); j = j + 1) {
			temp = inters_path.get(i);
			if(temp.distance >= min_dist) {
				//TODO it doesnt work (i may not win because lost before)
				if(i == 0 and temp.best_offer_id == my_state.agent_id) {
					speed = speed + 1;
					to_pay = temp.best_offer;
				} else {
					i = 1;
					k = agent.getPoints() + temp.best_offer / 2;
					agent.setPoints(k);
				}
			}
		}
	: k = agent.getPoints() - to_pay;
	: agent.setPoints(k);
	: res = new Action(speed);
	}
	
	void computeBestOffer() using PatternMatch {
	//We can assume that all agreed on every offer fufilling this conditions
	: when(IntersectionPlace p (p.distance != null and p.distance >= min_dist and p.distance < max_dist) &
		OfferMsg m (p.agents.contains(m.agent_id)) ) do {
			car = cur_state.get(m.agent_id);
			if(car.place != Position.C) i = len - car.position + (p.id - car.place.num + 4) % 4;
			else i = (p.id - car.position + 4) % 4;
			//Agents can let someone go even if he had lower offer
			//Only offers allowed by everyone are: highest offer and "let go" offers
			//Lowest offer is offer that everyone else "let go" so it wins
			if(p.best_offer > m.offers.get(i) ) {
				p.best_offer = m.offers.get(i);
				p.best_offer_id = m.agent_id;
				p.best_offer_speed = i;
			} else if(p.best_offer == m.offers.get(i)) {
				car2 = cur_state.get(p.best_offer_id);
				if(car.haste > car2.haste or (car.haste == car2.haste and m.agent_id < p.best_offer_id)) {
					p.best_offer = m.offers.get(i);
					p.best_offer_id = m.agent_id;
					p.best_offer_speed = i;
				}
			}
		}
	}

	void removeNotAccepted() using PatternMatch {
	//Check my offers
	: when(IntersectionPlace p (p.distance != null and p.distance >= min_dist and p.distance < max_dist) &
		AcceptMsg am (p.agents.contains(am.agent_id))) do {
			j = am.offers.indexOf(my_state.agent_id);
			if(j < 0 or am.speeds.get(j) > p.distance) {
				//my offer was not accepted (atm on best offer is my offer) 
				p.best_offer = null;
				p.best_offer_id = null;
				p.best_offer_speed = null;
			}
		}
	//Check if I accepted
	:  when(IntersectionPlace p (p.distance != null and p.distance >= min_dist and p.distance < max_dist) &
		OfferMsg om (p.agents.contains(om.agent_id))) do {
			car = cur_state.get(om.agent_id);
			if(car.place != Position.C) i = len - car.position + (p.id - car.place.num + 4) % 4;
			else i = (p.id - car.position + 4) % 4;
			j = acc_offers.indexOf(om.agent_id);
			if(j < 0 or speeds.get(j) > i) {
				//he is not allowed to go there, so remove him from possible collision list 
				p.agents.remove(om.agent_id);
			}
		}
	//Check other's offers
	: when(IntersectionPlace p (p.distance != null and p.distance >= min_dist and p.distance < max_dist) &
		OfferMsg om (p.agents.contains(om.agent_id)) &
		AcceptMsg am (am.agent_id != om.agent_id and p.agents.contains(am.agent_id))) do {
			car = cur_state.get(om.agent_id);
			if(car.place != Position.C) i = len - car.position + (p.id - car.place.num + 4) % 4;
			else i = (p.id - car.position + 4) % 4;
			j = am.offers.indexOf(om.agent_id);
			if(j < 0 or am.speeds.get(j) > i) {
				//he is not allowed to go there, so remove him from possible collision list 
				p.agents.remove(om.agent_id);
			}
		}
	}

	void processOffers() using Script {
	: wm.assertAll(offers);
	: invokeRuleBlock("getAccOffers");
	: res = new Action(acc_offers, speeds); 
	}
	
	void getAccOffers() using PatternMatch {
	: when(IntersectionPlace p (p.distance != null and p.distance >= min_dist and p.distance < max_dist) &
		OfferMsg m (p.agents.contains(m.agent_id)) ) do {
			car = cur_state.get(m.agent_id);
			if(car.place != Position.C) i = len - car.position + (p.id - car.place.num + 4) % 4;
			else i = (p.id - car.position + 4) % 4;
			if(p.best_offer < m.offers.get(i) or (p.best_offer == m.offers.get(i) and 
												 (car.haste > agent.getHaste() or (car.haste == agent.getHaste() and m.agent_id < p.best_offer_id)))) {
				j = acc_offers.indexOf(m.agent_id);
				if(j >= 0) {
					speeds.set(j, Math.min(speeds.get(j), i));
				} else {
					acc_offers.add(m.agent_id);
					speeds.add(i);
				}
			}
		} 
	}

	void processState() using Script {
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] processing State");
	
	: cur_state = in_state;	
	: my_state = cur_state.get(agent.getAgentId());
	: len = agent.getLength();
	: state_col = new AbleOclSequence(cur_state);
	: colliding = state_col.collect(colliding_cars);
	: wm.assertAll(colliding.asSequence());
	: max_dist = my_state.max_speed;
	: min_dist = my_state.max_speed;
	: for(i = 0; i < 4; ++i) {
			intersection.add(new IntersectionPlace(i, len));
		}
	:wm.assertAll(intersection);
	: if(agent.getDest() == my_state.dest) then
		turn = (agent.getDest().num - agent.getFrom().num + 4) % 4;
	: if(agent.getDest() != my_state.dest) then
		turn = (agent.getFrom().num - agent.getDest().num + 4) % 4;
	//First and last positions on intersection center
	: if(my_state.place != Position.C) then
		fst_inters = my_state.place.num;
	: if(my_state.place == Position.C) then
		fst_inters = my_state.position;
	: lst_inters = (my_state.dest.num + 1) % 4;
	//length of my path on the center of intersection (car moves in opposite direction than numbers grow)
	: inters_len = (fst_inters - lst_inters + 4) % 4;
	:invokeRuleBlock("computeStatistics");
	:invokeRuleBlock("computeAction");
	}

	void computeAction() using Policy {
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] computing Action");
	
	[1] : preconditions (my_state.dest == my_state.place) decisions {			
			//If I'm after intersection, then greedly take max possible speed
			speed = max_dist - 1;
			res = new Action(speed);
			
			println("[Agent " + String.valueOf(agent.getAgentId()) + "] greedy speed: " + String.valueOf(speed));
		}
	[1] : preconditions (my_state.place != Position.C and my_state.position + max_dist < len) decisions {
			//If I cannot arrive intersection, act greedly (TODO proposing car in front of me to move)
			speed = max_dist - 1;
			res = new Action(speed);
			
			println("[Agent " + String.valueOf(agent.getAgentId()) + "] greedy speed: " + String.valueOf(speed));
		}
	[1] : preconditions (min_dist == max_dist) decisions {
			//Have only one option
			speed = max_dist - 1;
			res = new Action(speed);
			
			println("[Agent " + String.valueOf(agent.getAgentId()) + "] greedy speed: " + String.valueOf(speed));
		}
	[0] : preconditions (min_dist < max_dist) decisions {
			invokeRuleBlock("valuePlaces");
			invokeRuleBlock("computeOffer");
			res = new Action(offer);
		}
	}
	
	
	//Only option for getting here is possibility of crossing intersection this moment
	//and having possible collision after min_dist steps
	void computeOffer() using Script {
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] computing Offer");
	
	: max_spend = ((Float) agent.getHaste()) / 5 * agent.getPoints();
	: if(my_state.place != Position.C)
		i = (fst_inters - (min_dist - (len - my_state.position)) + 4) % 4;
	else 
		i = (fst_inters - min_dist + 4) % 4; 
	: temp = inters_path.get(i);
	: sum_wait = temp.expect_tot_time;
	: for( j = 0; j < min_dist; j = j + 1) {
			offer.add(0);
		}
	: for(j = min_dist ; j < max_dist and i < inters_path.size(); j = j + 1, i = i + 1) {
			temp = inters_path.get(i);
			tmp = temp.expect_tot_time / sum_wait * max_spend;
			k = Math.round(tmp);
			offer.add(k);
			temp.best_offer = k;
			temp.best_offer_id = my_state.agent_id;
			temp.best_offer_speed = j;
			
			if(temp.distance != j) println("BUG: temp.distance = " + String.valueOf(temp.distance) + ", j = " + String.valueOf(j));
			
			println("[Agent " + String.valueOf(agent.getAgentId()) + "] offer " + String.valueOf(k) + " for speed " + String.valueOf(j));
		}
	}

	void valuePlaces() using Script {
	: Collections.sort(inters_path); //sort ascending by distance
	
	: if(inters_len != inters_path.size()) println("BUG: inters_len = " + String.valueOf(inters_len) + " inters_path.size = " + String.valueOf(inters_path.size()));
	: temp = inters_path.get(0);
	: if(inters_path.size() > 0 and (fst_inters - 1) % 4 != temp.id)  println("BUG: fst_inters = " + String.valueOf(fst_inters) + " inters_path.first = " + String.valueOf(temp));
	
	: for(i = inters_path.size() - 1 ; i >= 0 ; i = i - 1) {
			temp = inters_path.get(i);
			temp.expect_wait_time = 0;
			invokeRuleBlock("expectedWaiting(Integer)", new Object[] {i}); //cannot nest loops 
			temp.expect_tot_time = ((int) (inters_len - i - 1) / agent.getMaxSpeed() + 1) + temp.expect_wait_time;
		}
	}
	
	void expectedWaiting(Integer place_idx) using Script {
	: j = 1;
	: temp = inters_path.get(place_idx);
	: while ( j < len - 1 & temp.future_agents.get(j) > 0 ) do {
			j = j+1;
		}
	: for( ; j > 0; j = j - 1) {
			//assume that every agent have the same chance to cross intersection in this place 
			//it's not exactly expected value - not counting vehicles that will be waiting with me
			multiplier = 1 - 1/((Float) temp.future_agents.get(j) + 1);
			temp.expect_wait_time = multiplier*(temp.expect_wait_time + 1); 
		} 
	: if(place_idx < inters_len - 1) then {
			temp2 = inters_path.get(place_idx + 1);
			temp.expect_wait_time = temp.expect_wait_time + temp2.expect_wait_time;
		}
	}
	
	
	void computeStatistics() using PatternMatch {
	: println("[Agent " + String.valueOf(agent.getAgentId()) + "] computing Statistics");
	//When there is another car on my trajectory i cannot go further
	//This covers cases when this car is not in the center
	: when(AgentState car (car.place != Position.C and ((my_state.place == car.place and my_state.position < car.position and my_state.position + max_dist > car.position) or
														(my_state.dest == car.place and my_state.place != my_state.dest and
														((my_state.place == Position.C and max_dist - inters_len > car.position) or
														(my_state.place != Position.C and my_state.position + max_dist - len - inters_len > car.position)))))) do {
			max_dist = my_state.position - car.position;
			min_dist = Math.min(min_dist, max_dist);
		}
	//find center positions on agent's path
	: when(IntersectionPlace p ((p.id != my_state.position or my_state.place != Position.C) and (fst_inters - p.id + 4) % 4 <= inters_len)) do {
			if(my_state.place != Position.C) p.distance = len - my_state.position + (p.id - fst_inters + 4) % 4;
			else p.distance = (p.id - fst_inters + 4) % 4;
			inters_path.add(p);
		}
	//for every such position compute how on many agent trajectories it lies (and some addidtional statistics) 
	: when(IntersectionPlace p (p.distance != null) & 
		AgentState car (car.agent_id != my_state.agent_id and (car.place != Position.C and (car.place.num - p.id + 4) % 4 <= (car.place.num - (car.dest.num + 1) % 4) % 4) or
															  (car.place == Position.C and (car.position - p.id + 4) % 4 <= (car.place.num - (car.dest.num + 1) % 4) % 4))) do {
			if(car.place != Position.C) i = len - car.position + (p.id - car.place.num + 4) % 4;
			else i = (p.id - car.position + 4) % 4;
			i = (i - 1) / my_state.max_speed;
			j = p.future_agents.get(i) + 1;
			p.future_agents.set(i, j);
			if(car.place == Position.C and car.position == p.id) {
				max_dist = Math.min(max_dist, p.distance);
				min_dist = Math.min(min_dist, max_dist);
			}
			if(i == 0) {
				min_dist = Math.min(min_dist, p.distance); 
				i = car.agent_id;
				p.agents.add(i);
			}
		}
	}
	
}