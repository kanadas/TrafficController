//Offer values are based on haste, current money and approximate expected waiting time if let go 
//Bidding rules:
//After getting bids from all other agents, agent processes them and decides what can he accept
//Agent may accept lower offer than his, but cannot refuse higher offer
//If there are two equal offers wins agent with bigger haste, if they have equal haste wins agent with smaller agent_id

ruleset Car {
	import java.lang.String;
	import java.lang.Math;
	import java.util.ArrayList;
	import java.util.Collections;
	import java.util.List;
	import logging.Logger;
	import simulation.Agent;
	import simulation.Simulation;
	import simulation.AgentState;
	import simulation.Direction;
	import simulation.CenterPlace;
	import simulation.Action;
	import simulation.Intersection;
	import messages.OfferMsg;
	import messages.AcceptMsg;
	import com.ibm.able.rules.AbleOclSequence;
	
  	variables {
  		static Logger logger;
  	
		Agent agent;
		List cur_state;
		List offers;
		List accepts;
		
		Integer len;		
		static AgentState my_state;
		static Integer max_dist;
		static Integer min_dist;
		static Intersection intersection;
		static CenterPlace fst_center;
		static CenterPlace lst_center;
		static Integer center_len;
		static List center_path;
		static List intersecting_agents = new ArrayList();
		static Integer offer;
		static List accepted_offers;
		
		Double expected_wait_time;
		Double expected_total_time;
		Boolean accepted;
		Double sum_wait;
		Integer payment;
		Integer new_payment;
		Boolean paying;
		Integer speed;
		Action res;	

		AgentState car;
		//keep only agents that can impact my decision (the ones behind are removed)
		Expression Collides = car.agent_id != my_state.agent_id and car.waiting_time == 0 and
			(intersection.isInFront(my_state, car) or intersection.trajectoriesIntersect(my_state, car));
		Selector collidingCars = new Selector(this.getVariable("car"), Collides, true);
	}

	inputs{agent, cur_state, offers, accepts};

	outputs{res};

	void process() using Script {
	variables {
		Integer new_points;
	}
	: logger = new Logger(agent.getAgentId());
	: logger.trace("processing");
	: len = agent.getLength();
	: if(offers == null and accepts == null) {
			invokeRuleBlock("processState");
		}
	: if(offers != null) {
			invokeRuleBlock("processOffers");
		} 
	: if(accepts != null) {
			invokeRuleBlock("processAccepts");
			if(paying) {
				payment = payment - offer;
			}
			logger.trace("speed = %d, payment = %d", speed, payment);	
			new_points = agent.getPoints() + payment;
			agent.setPoints(new_points);
			res = Action.commit(speed);
		}
	}
	
	void processState() using Script {
	variables {
		AbleOclSequence pom_seq;
		AbleOclSequence colliding;
	}
	: logger.trace("processing State");
	: my_state = cur_state.get(agent.getAgentId());	
	: intersection = new Intersection(len);
	: pom_seq = new AbleOclSequence(cur_state);
	: colliding = pom_seq.select(collidingCars);		
	: wm.assertAll(colliding.asSequence());
	: fst_center = intersection.getFirstPlace(my_state);
	: lst_center = intersection.getLastPlace(my_state);
	: center_path = intersection.getPath(fst_center, lst_center);
	: if(my_state.place == Direction.C) 
		center_path.remove(0);
	: center_len = center_path.size();
	: logger.debug("fst_center = %s, lst_center = %s, center_len = %d", String.valueOf(fst_center), String.valueOf(lst_center), center_len);
	: wm.assertAll(intersection.getPlaces());
	: max_dist = my_state.max_speed;
	: min_dist = my_state.max_speed;
	: invokeRuleBlock("computeMaxDist");
	: logger.debug("max_dist = %d", max_dist);
	: invokeRuleBlock("computeAction");
	}
	
	void computeMaxDist() using PatternMatch {
	: logger.trace("computing max dist");
	: when(AgentState car ((intersection.isInFront(my_state, car) || (car.place == Direction.C && center_path.contains(intersection.getAgentPlace(car)))) && 
							intersection.distance(my_state, car) <= max_dist)) do {
			logger.debug("car on trajectory: %d", car.agent_id);
			max_dist = intersection.distance(my_state, car) - 1;
		}
	}

	void computeAction() using Policy {
	: logger.trace("computing Action");
	[1] : preconditions (my_state.dest == my_state.place) decisions {
			//If I'm after intersection, then greedly take max possible speed
			speed = max_dist;
			res = Action.commit(speed);
			logger.trace("greedy speed: %d", speed);
		}
	[1] : preconditions (my_state.place != Direction.C and my_state.position + max_dist < len) decisions {
			//If I cannot arrive intersection, act greedly
			speed = max_dist;
			res = Action.commit(speed);
			logger.trace("greedy speed: %d", speed);
		}
	[0] : preconditions (true) decisions {
			invokeRuleBlock("computeStatistics");
			min_dist = Math.min(min_dist, max_dist);
			logger.debug("min_dist = %d", min_dist);
			if(min_dist == max_dist) {
				speed = max_dist;
				res = Action.commit(speed);			
				logger.trace("greedy speed: %d", speed);
			} else {
				invokeRuleBlock("valuePlaces");
				logger.debug("expected_total_time = %f", expected_total_time);
				offer = agent.computeOffer(expected_total_time); 
				res = Action.offer(offer);
			}
		}
	}
	
	void computeStatistics() using PatternMatch {
	variables {
		Integer turns_to;
		Integer tmp;
	}
	: logger.trace("computing Statistics");
	//for every such position compute how on many agent trajectories it lies (and some addidtional statistics) 
	: when(AgentState car (car.place != car.dest) &
		CenterPlace p (intersection.onTrajectory(p, car))) do {
			logger.debug("intersection %d on path of %d, distance=%d ", p.id, car.agent_id, intersection.distance(car, p));
			turns_to = (intersection.distance(car, p) - 1) / car.max_speed;
			tmp = p.future_agents.get(turns_to) + 1;
			logger.debug("turns_to = %d, new value = %d", turns_to, tmp);
			p.future_agents.set(turns_to, tmp);
			if(turns_to == 0) {
				p.agents.add(car.agent_id);
				intersecting_agents.add(car.agent_id);
			}
			if(turns_to == 0 and center_path.contains(p)) {
				min_dist = Math.min(min_dist + 1, intersection.distance(my_state, p)) - 1;
			}
		}
	}
		
	void valuePlaces() using PatternMatch {
	: logger.trace("computing Offer");
	: expected_total_time = 0;  	
	: when(CenterPlace p (center_path.contains(p))) do {
			expected_wait_time = 0;
			invokeRuleBlock("expectedWaiting(CenterPlace,Integer,Integer)", new Object[] {p, 0, 0});
			logger.debug("expected_wait_time = %f for place %d", expected_wait_time, p.id);
			expected_total_time = expected_total_time + expected_wait_time;
		}
	}
	
	//assume that every agent have the same chance to cross intersection in this place, and all except one will wait
	void expectedWaiting(CenterPlace place, Integer waiting_for, Integer agents_waiting) using Script {	
	variables {
		Double chance_to_go;
	}
	: agents_waiting = place.getFutureAgents().get(waiting_for) + agents_waiting;
	: if(agents_waiting != 0) {
			chance_to_go = 1/((Double) agents_waiting + 1);
			//recursively compute expected waiting if waiting now
			invokeRuleBlock("expectedWaiting(CenterPlace,Integer,Integer)", new Object[] {place, waiting_for + 1, agents_waiting - 1});
			expected_wait_time = (1 - chance_to_go) * (expected_wait_time + 1); //+ 0*chance_to_go
		} else {
			expected_wait_time = 0;
		}
	}
		
	void processOffers() using Script {
	: logger.trace("processing Offers");
	: wm.assertAll(offers);
	: accepted_offers = new ArrayList();
	: logger.debug("my offer = %d", offer);  
	: invokeRuleBlock("getAccOffers");
	: res = Action.accept(accepted_offers); 
	}

	void getAccOffers() using PatternMatch {
	: when(OfferMsg m (intersecting_agents.contains(m.agent_id))) do {
			car = cur_state.get(m.agent_id);
			if(agent.acceptsOffer(car, m.offer, offer)) {
				logger.debug("accepted offer %d from agent %d", m.offer, m.agent_id);
				accepted_offers.add(m.agent_id);
			} 
		}	
	}
	
	void processAccepts() using PatternMatch {
	variables {
		Integer distance;
	}
	: logger.trace("processing Accepts");
	: wm.assertAll(accepts);
	: speed = max_dist;
	: paying = false;
	: payment = 0;
	: when(CenterPlace p (center_path.contains(p) and intersection.distance(my_state, p) > min_dist and !p.agents.isEmpty())) do {
			invokeRuleBlock("checkAgents(CenterPlace)", new Object[] {p});
			distance = intersection.distance(my_state, p) - 0;
			if(accepted && speed >= distance) {
				logger.debug("Cannot go further than %d, new payment = %d", distance, new_payment);
				speed = distance - 1;
				payment = new_payment;
				paying = false;
			}
		}
	}
	
	void checkAgents(CenterPlace p) using PatternMatch {
	: logger.trace("checking agents for place %d", p.getId());
	: when(AgentState car (p.getAgents().contains(car.agent_id))) do {
			accepted = true;
			invokeRuleBlock("checkIfAccepted(CenterPlace,AgentState)", new Object[] {p, car});
			if(accepted) {
				if(accepted_offers.contains(car.agent_id)) {
					logger.trace("agent %d blocks my path on position %d", car.agent_id, p.getId());
					invokeRuleBlock("getPayment(CenterPlace,AgentState)", new Object[] {p,car});
				} else {
					logger.trace("I block path of agent %d position %d", car.agent_id, p.getId());
					accepted = false;
					paying = true;
				}
			}
		}
	}
	
	void checkIfAccepted(CenterPlace dest, AgentState car) using PatternMatch {
	: logger.debug("checking if %s is accepted for %s", dest.toString(), car.toString());
	//Find place on which car is forbidden to enter
	
	: when(CenterPlace p (accepted) &
		AcceptMsg msg (msg.agent_id != car.getAgentId() and p.onPathOf(msg.agent_id) and !msg.offers.contains(car.getAgentId())) &
		OfferMsg offer (offer.agent_id == car.getAgentId())) do {
			
			if(intersection.distance(car, p) <= intersection.distance(car, dest)) {
				accepted = false;
				logger.debug("place not accepted");
			}
		}
	}

//For unknown reason, without this first unused parameter, function doesn't work anymore
	void getPayment(CenterPlace p, AgentState car) using PatternMatch {
	: when(OfferMsg offer (offer.agent_id == car.getAgentId())) do {
			new_payment = offer.offer;
		}
	}	
}